## Переменные и функции

### Переменные

Переменные и функции с большой буквы - экспортируемые

##### Объявление переменных

Переменные объявляются с помощью

```go
var i int // Первый вариант
j:=0      // Второй вариант
```

Если объявлять через `var` - устанавливаются значения по умолчанию(нули, пустые строки, nil)

Если объявлять через `:=` - тип переменной определяется автоматически по переданному справа значению

##### Типы переменных

Переменные не могут менять тип после создания

Конвертация происходит с помощью вызова нужного типа и в скобках конвертируемое значение. При переводе из одного типа в другой конвертация обязательна. Пример:

```go
var f float64 = math.Sqrt(float64(x*x + y*y))
var z uint = uint(f)
```

##### Константы

Константы объявляются с помощью `const Pi = 3.14`. Константами могут быть только базовые типы(числа, булы, строки, символы)

##### Указатели

Можно создать указатель на переменную. Прям как в C++ со всеми вытекающими. Но не поддерживается математика над указателями(нельзя перейти по массиву с помощью преобразования указателя)

Указатели можно использовать в функциях и методах структур в качестве аргумента. При этом в функциях идет строгая типизация(то есть если аргумент - объект, то нужно обязательно передать объект, а не ссылку на объект. верно и обратное), то в методах структур работа всегда идет над объектом, для которого вызвана функция(чтобы мы не написали в аргументе функции, работа всегда будет вестись над оригинальным объектом)

##### Type

Можно определять свои названия типов над базовыми. Это нужно для привязки методов для базовых типов. Пример:

```go
type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f < 0 {
        return float64(-f)
    }
    return float64(f)
}

func main() {
    f := MyFloat(-math.Sqrt2)
    fmt.Println(f.Abs())
}

```

### Функции

Могут быть присвоены переменной и переданы. Например, `func compute(fn func(float64, float64) float64) float64` ожидает первым аргументом функцию от 2 переменных типа float. Внутри функции compute можно использовать функцию fn

##### Аргументы

Функции принимают 0 и больше аргументов, вид функции: `func add(x int, y int) int`===`func add(x, y int) int`

##### Возвращаемые значения

Функции могут возвращать любое кол-во переменных, например `func swap(x, y string) (string, string)` - вернет 2 стринга

Возвращаемые значения можно именовать, тогда в коде сразу доступны переменные для возврата значений, например

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

В этой функции сразу можно обращаться к результирующим переменным без дополнительного их объявления.

**Миксовать именованный и не именованный возврат нельзя**. То есть следующая функция работать не будет

```go
func split(sum int) (x int, int) {
	x = sum * 4 / 9
	y = sum - x
	return y
}
```

#### Замыкания

В Go реализованы замыкания функций. Не совсем понимаю зачем, но выглядит это так

```go
func main() {
    // Определяем функцию makeMultiplier, которая возвращает замыкание
    // здесь переменная factor захватывается внутри замыкания
    makeMultiplier := func(factor int) func(int) int {
        // Это замыкание, которое умножает переданное число на factor
        return func(x int) int {
            return x * factor
        }
    }

    // Создаем замыкание с factor равным 3
    multiplyByThree := makeMultiplier(3)
    // Вызываем замыкание
    fmt.Println("Multiplying 2 by 3:", multiplyByThree(2)) // Выводит: 6

    // Создаем замыкание с factor равным 5
    multiplyByFive := makeMultiplier(5)
    // Вызываем замыкание
    fmt.Println("Multiplying 2 by 5:", multiplyByFive(2)) // Выводит: 10
}
```

#### Паника

В Go своя особая идеология ошибок. Вместо try catch используется panic/recover. Причем паника - это не обычная ошибка, которая может вернуться из выполняемой функции, а скорее Exception, который всплывает по стеку вызова наверх и пытается убить главную корутину. Но при этом нельзя использовать его как Exception из PHP. Паника - это прям жопа, а обычные отлавливаемые ошибки - всегда должны возвращаться последним аргументом

Для вызова `panic(arg)`. Вместо `arg` может поставить что угодно

Для обработки паники используется ключевое слово `recover`. По сути - catch

#### Интерфейсы

Интерфейс в Go отличаются в своей реализации от интерфейсов в PHP. Они не говорят структуре напрямую, какие функции он должен реализовывать. Они предполагают, что метод уже реализован в объекте и только дают возможность вызвать этот метод внутри кода

Пример:

```go
// Объявляем интерфейс
type Abser interface {
	Abs() float64
}

func main() {
    // Создаем его. Структуры, которым он присваивается, должны реализовывать функцию Abs, но сами структуры об этом не знают
    var a Abser
    f := MyFloat(-math.Sqrt2)
    v := Vertex{3, 4}
    // Говорим, что в переменную a Abser мы положим те структуры, которые реализуют функцию Abs
    a = f  // a MyFloat implements Abser

    // Так как в Vertex функция Abs реализована только для указателя, то этот код вызовет ошибку.
    a = v
    // Вот так - не вызовет, так как для указателя функция реализована
    a = &v // a *Vertex implements Abser
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```

Также интерфейсы можно ожидать в качестве аргументов функции. Тогда мы ожидаем только такие структуры, которые реализуют этот интерфейс

```go
type I interface {
	M()
}

type T struct {
	S string
}

// This method means type T implements the interface I,
// but we don't need to explicitly declare that it does so.
func (t T) M() {
	fmt.Println(t.S)
}

func main() {
	var i I = T{"hello"}
	i.M()
}
```

В функциях, которые реализуют интерфейс, можно описывать поведение для нулевого объекта(nil). То есть можно запускать функции на нулевые объекты.
При этом интерфейс не может сам от себя вызывать функции. Ну, логично, описания реализации то нет

Можно создавать пустые интерфейсы и использовать их. Это используется для того, чтобы передавать любые переменные в функцию(как базовые типы, так и структуры)
Пример:

```go
func main() {
	var i interface{}
	describe(i)

	i = 42
	describe(i)

	i = "hello"
	describe(i)
}

func describe(i interface{}) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```

С помощью проверки типа можно триггерить панику. То есть когда у нас есть интерфейс и мы проверям тип переданного значения и если это значение не совпадает, то получаем досрочное завершение программы. Паника триггериться только в рантайме!
Пример:

```go
func main() {
    // Мы создаем пустой интерфейс, реализацию которого представляем в типе стринг
	var i interface{} = "hello"
    // Проверяем, что тип действительно стринг и выводим
	s := i.(string)
	fmt.Println(s)
    // ok возвращает true, если тип совпал
	s, ok := i.(string)
	fmt.Println(s, ok)
    // А здесь ok вернет false, то есть мы не ожидали такой тип
	f, ok := i.(float64)
	fmt.Println(f, ok)
    // Вот здесь будет досрочное завершение программы, так как ok мы не забирали
	f = i.(float64) // panic
	fmt.Println(f)
}
```

Самый часто используемый интерфейс - интерфейс `Stringer`. Он определяет возможность преобразования переменной в строку. Требует реализации функции `String() string`

Также часто используется интерфейс `Reader`. Он описывает функцию `Read([]byte) (int, error)`, которая говорит как можно считывать массив байт. Не думаю что это будет полезно на текущий момент, дефолтная реализация есть очень много где (подробнее смотри [здесь](https://go.dev/tour/methods/21))

Базовые типы без слайсов и мапов, а так же структуры без аргументов в виде слайсов и мапов реализуют интерфейс `comparable`, то есть могут быть использованы в мапах или в других сравнениях

Также существуют интерфейсы, которые описывают только тип. Они используются в дженериках. Пример:

```go
type Number interface {
    int64 | float64
}
```

## Циклы и условия

### Циклы

Все циклы используют for

Обычный цикл for `for i := 0; i < 10; i++`

В виде while `for sum < 1000`

В виде foreach `for i, v := range pow`, где i - индекс в массиве/слайсе, v - копия объекта

### Условия

#### if

Условие - `if (x < 0)` === `if x < 0`

В условии можно выполнять присваивание переменных `if v := math.Pow(x, n); v < lim`

В условиях поддерживается else

#### switch

В switch выполняется только первое сыгравшее условие. `break` не нужен

В case можно выполнять функции и проверять соответствие по результату выполнения функции

Пример switch

```go
switch os := runtime.GOOS; os {
case getSomethingFromSomewhere():
    fmt.Println("OS X.")
case "linu"+"x":
    fmt.Println("Linux.")
default:
    fmt.Printf("%s.\n", os)
}
```

Пустой switch === switch true. Пример

```go
switch {
case t.Hour() < 12:
    fmt.Println("Good morning!")
case t.Hour() < 17:
    fmt.Println("Good afternoon.")
default:
    fmt.Println("Good evening.")
}
```

##### switch type

Можно делать условный переход по типу полученного значения. Пример:

```go
func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}

```

## Defer

Функция defer добавляет в конец вызванной функции некоторый функционал. То есть вызывается перед тем как покинуть функцию. То есть ее можно вызвать, чтобы после некоторой логики как то мутировать окончательные значения, например. Обычно используется для закрытия каналов и прочего

Defer добавляется с помощью стека. То есть первый встреченный defer будет выполнен последним. При этом положить в стэк можно несколькими способами

```go

/*
Вывод будет
first 9
first 8
...
first 0

То есть значения будут вычислены(так как это константа) и переданы в defer stack уже в конечном виде
*/
for i:=0;i<10;i++{
	defer fmt.Println('first',i)
}

/*
Вывод будет
second 10
second 10
...
second 10

То есть в стэк будет положена ссылка на i и потом разыменована
*/
for i:=0;i<10;i++{

	// defer func(){
	//			лямбда функция, которая должна что-то сделать
	//}() //вызов лямбда функции, сюда можно передавать аргументы
	defer func(){
	 fmt.Println('second',i)
	}()
}
```

## Структуры

Структура - это объект с полями. Доступ к аргументами объекта через dot нотацию. Пример:

```go
type Vertex struct {
    X int
    Y int
}
```

На объекты можно ссылаться с помощью указателей. При обращении по указателю действия будут производиться непосредственно с объектом без дополнительных команд(как будто работаешь с самим объектом)

##### Создание объектов структур

Можно вызывать конструктор структуры при создании объекта. Больше всего мне нравится с явным указанием переменной для внесения данных

```go
type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
)

func main() {
	fmt.Println(v1, p, v2, v3) // Вывод - {1 2} &{1 2} {1 0} {0 0}
}
```

##### Методы структур

Классов в Go нет. Но можно создавать методы для структур. По сути мы к некоторый структуре привязываем функцию, которую можем исполнять для этой структуры

```go
type Vertex struct {
	X, Y float64
}
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
}
```

Также в методах можно передавать указатели на структуру. Тогда работа метода будет произведена непосредственно над переданной структурой и ее аргументы могут быть изменены.

Если передан указатель на структуру - работа будет производиться всегда над объектом. Можно отдельно не определять адрес объекта, он все равно будет использован

```go
func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(10)// Каждый аргумент оригинальной структуры будет изменен
}
```

Надо обязательно выбрать один стиль(или объект или указатель) для одной структуры и его придерживаться.

## Массивы, слайсы, мапы(map)

Индексация массивов и слайсов идет с 0. К элементу можно обращаться по цифровому индексу как в C++. Если индекс не цифра - смотри `map`

#### Массивы

В Go массивы не динамические, то есть память выделяется один раз

Пример создания массива `var a [2]string`

#### Слайсы

##### Определение и создание

По сути слайсы - это массивы указателей. По умолчанию = nil

Слайсы могут быть созданы на основе массива. Создаются с помощью 2 индексов [low:high].Low - указывает левую часть, по умолчанию 0. High - указывает правую часть, по умолчанию - размер массива. Low и High могут быть опущены, тогда будут иметь свое значение по умолчанию
Пример:

```go
primes := [6]int{2, 3, 5, 7, 11, 13}
var s []int = primes[1:4]
mt.Println(s) //Вывод - [3 5 7]
```

Разница при создании слайса и массива - в цифре внутри []. Если без цифры - слайс, иначе - массив

Можно создать слайс без предварительного создания массива, тогда под капотом будет создан массив и к нему приделан слайс(`[]bool{true, true, false}`)

У слайсов есть длина(len) и вместительность(cap). Длина - это количество элементов в текущем слайсе, вместительность - это размер массива, над которым был создан слайс. Выходить за рамки вместительности просто так нельзя, надо явно расширять изначальный массив

С помощью функции `make` можно динамически создавать массивы. Первый аргумент - длина, второй - вместительность
Пример:

```go
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```

С помощью слайсов можно создавать многомерные массивы. В принципе слайсы могут хранить в себе какие угодно структуры данных

##### Расширение

Расширять слайсы можно с помощью команды append. В команду append передаются новые элементы, которые нужно добавить в слайс. Если изначальный массив слишком мал, будет создан новый массив с нужными элементами и слайс начнет ссылаться на него

#### Map

Мапа используется в качестве ассоциативного массива. В качестве ключа могут быть использованы базовые типы, а так же структуры без слайсов и мапов. Все такие типы имлиментируют интерфейс `comparable`. По умолчанию(без указания типа) равен nil. В map=nil нельзя добавить ключи или как то его расширить

Пример инициализации:

```go
// Динамическое добавление
m = make(map[string]Vertex)
m["Bell Labs"] = Vertex{
	40.68433, -74.39967,
}
fmt.Println(m["Bell Labs"])

//Инициализация с значениями
var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}
```

Над мапами можно производить следующие операции:

1. Добавление - `m[key] = elem`
2. Взять значение - `elem = m[key]`
3. Уничтожить элемент - `delete(m, key)`
4. Проверить существует ли элемент в мапе - `elem, ok = m[key]`. Если ok=== true, то существует, иначе key=== false и элемент берет значение по умолчанию согласно типу элементов в мапе

## Ошибки

Все ошибки реализуют интерфейс `error`, в котором определена функция `Error() string`

Если ошибка === nil, то выполнение функции успешно. Иначе - при выполнении произошла ошибка

Пример кастомной ошибки с отдельной логикой вывода:

```go
// Структура кастомной ошибки
type MyError struct {
	When time.Time
	What string
}

// Поведение кастомной ошибки
func (e *MyError) Error() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() error {
    // Бросаем ссылку на ошибку. То есть создаем объект один раз и пробрасываем его вверх
	return &MyError{
		time.Now(),
		"it didn't work",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}
```

## Image

Изображения, которые имплементируют интерфейс `Image` - это не только сами фотографии, но и также всяческие фигуры, которые конструируются внутри системы(круги, квадраты, прочее). Интерфейс должен быть реализован следующим образом:

```go
type Image interface {
    // Используем RGBA или CMYK или еще какую срань
    ColorModel() color.Model
    // Границы изображения. Всегда прямоугольник в том или ином виде
    Bounds() Rectangle
    At(x, y int) color.Color
}
```

Пример:

```go
func main() {
    // Создаем новый прямоугольник, который
	m := image.NewRGBA(image.Rect(0, 0, 100, 100))
	fmt.Println(m.Bounds())
	fmt.Println(m.At(0, 0).RGBA())
}
```

## Generic

###### Функции

Позволяют в этом строго типизированном языке создать функцию, которая может принимать один из нескольких возможных типов. По факту это как `f(int|string $v)` в php

Синтаксис:

```go
//[Generic int64|float64] - мы создаем временный тип, который может принимать int64 или float64. После вызова функции тип определен и не может быть изменен.
// Конкретно в этом примере - если мы вызываемся от int64, то float64 уже не вернем
func sum[Generic int64|float64](numbers []Generic) Generic{
    var sum Generic
    for i:=range numbers {
        sum+=numbers[i]
    }
    return sum
}

//Вызов функции
sum(floats)
// Можно явно указать тип переменной, которую мы туда передаем
sum([int64](ints))
```

В качестве типа кроме перечисления можно также передать интерфейс `comparable`. То есть функция `func sum[Generic int64|float64](numbers []Generic) Generic{` превращается в `func sum[Generic comparable](numbers []Generic) Generic{`
По сути мы говорим, что ожидаем практически любой тип и такой же ответ вернем

Также можно использовать тип any. Это тип, который является алиасом на interface {}. То есть прям вообще любой тип можно передать

Вообще в дженерики можно передавать любой интерфейс, который описывает только типы. Например, такой:

```go
type Number interface{
    int64 | float64
}
```

###### Переменные

Дженерики также можно использовать в типах для того, чтобы переменная этого типа могла принимать значение одного из типов дженерика. Выглядит следующим образом:

```go
type Number interface{
    int64 | float64
}

// Мы создали тип Numbers, который является слайсом переменных либо int64, либо float64
type Numbers[T Number] []T

func main(){
    // Создаем переменную и говорим, что у нее тип будет int64. То есть только один тип из дженерика мы можем использовать
    var ints Numbers[int64]
    // Второй вариант
    floats:=Numbers[float64]{1.0,2,3,4,5}
}
```

Также есть такая штука как апроксимация типов. В дженериках мы можем указать, чтобы он мог использовать все типы, которые основаны на некотором типе. Пример:

```go
type CustomInt int64
// Обрати внимание на ~. Без нее создать переменную типа CustomInt, которая бы реализовывала интерфейс Number я бы не смог, требовалось бы полное соответствие. А так - можно
type Number interface{
    ~int64 | float64
}

func main(){
    var number Number
    var custInt CustomInt
    // Возможно только с ~
    number=custInt
}

```

## Корутины

Корутины - это легковесные треды. То есть там, под капотом, они как то работают, но для нас это будет просто новый поток, в котором будут выполняться функции. Они будут работать в том же пространстве - то есть над теми же переменными и надо следить за синхронизацией доступа к памяти

Всегда есть как минимум одна корутина - это корутина главной функции main.

Корутины выполняются на функциях с использованием команды go `go slowFunc()`

Конец выполнения программы означает досрочное(возможно) завершение всех корутин. То есть программа не будет ждать завершения потока, чтобы завершиться, если не использовать специальные операторы

Одновременно(Параллельно!) может выполняться только некоторое количество корутин. Количество зависит от количества логических ядер процессора. Вернуть это количество можно с помощью команды `runtime.NumCPU()`.
Можно уменьшить количество одновременно(параллельно) выполняемых корутин с помощью команды `runtime.GOMAXPROCS(int)` (например, для уменьшения нагрузки)

Можно вручную сказать Go когда мы хотим переключиться на другую корутину с помощью команды `runtime.Gosched()`

#### Блокировки

##### Wait group

Для того, чтобы дождаться выполнения корутин перед выходом из программы используются функции WaitGroup Add, Done, Wait

Add всегда должен быть вызван ДО той корутины, которую мы хотим трекать. Вообще корутина может сама себя(при Add внутри корутины) поместить в трекер, но только если она начнет выполняться. Если она не успеет выполнится, то мы просто не узнаем о ее существовании

По сути Add и Done просто увеличивают и уменьшают счетчик, а Wait ждет пока счетчик не станет равным 0. То есть сами потоки никуда и нигде не регистрируются отдельно

Пример:

```go
// Создаем wait group, в который будем помещать наши корутины
var wg sync.WaitGroup

for i:=0; i<10; i++{
	// Принимает количество задач, которые надо добавить в wait группу
	wg.Add(1)
	// Создаем задачу. Она автоматически добавляется в wait группу, если в ней есть свободный слот
	go func(i int){
		fmt.Println(i+1)
		// !!!Обязательно должны сказать, что функция завершена. По сути resolve
		// Лучше вызывать с помощью defer
		wg.Done()
	}(i)

	//Дожидаемся выполнения всех задач
	wg.Wait()
}
```

#### Data race

Если мы используем мультипоточность, то может быть и датарейс. То есть кто успел, тот и использовал текущее значение переменной, а остальные могут получить что-то другое или перезаписать это текущее значение и потерять данные

Решением будет использование mutex, то есть блокировки доступа к выполняемому коду на какой то период

Пример

```go
var wg sync.WaitGroup
// Создаем мьютекс
var mu sync.Mutex
counter:=0
wg.Add(10)

for i:=0; i<1000; i++{
	go func(i int){
		defer wg.Done()
		// Обрати внимание, что мьютекс один и тот же на все 1000 корутин. И все остальные 999 корутин ждут выполнения этого участка кода 1 корутины
		mu.Lock()
		counter++
		mu.Unlock()
	}(i)

	//Дожидаемся выполнения всех задач
	wg.Wait()
}
// Без использования mutex получим каждый раз разное значение
fmt.Println(counter)
```

Однако иногда необходимо разделять блокировку на чтение и блокировку на запись. Допустим, выполнять эксклюзивную(полную) блокировку на чтение смысла нет, так как ничего не поменяется, если корутина a, потом b прочитает значение или наоборот. Но вот в процессе чтения переменная изменяться не должна

Для этого придумали RWMutex. Он добавляет новый функционал `RLock` и `RUnlock`. Эту штуки работают так же, как и обычные `Lock` и `Unlock`, но при этом не создают эксклюзивную блокировку. То есть читать может кто угодно, писать - только одна функция

#### Каналы

Каналы - это способ отправки данных между потоками. Каналы нужно создавать перед использованием. Для передачи данных в каналы необходимо использовать оператор <-, направление стрелки указывает куда что передать(вытащить из канала или передать в канал переменную)

Структура канала:

```go
type chan struct{
	mx sync.mutex //mutex, который блокирует общение в канале на момент записи
	buffer []T // Буфер канала
	readers []Goroutines // Очередь читающих канал
	writers []Goroutines // Очередь пишущих в канал
}
```

У канала есть длина и капасити(capacity). Длина - это текущее количетсво элементов в канале. Капасити - это максимальный объем данных внутри канала.

Каналы бывают буфферизированные и не буфферизированные.

Если канал небуфферизированный, то у него должен быть и читатель и писатель. То есть должен быть в стек положен код, который читает данные из канала и код, который пишет в канал. Если писателя или читателя нет - дедлок.

Если канал буфферизированный, то пока буфер не переполниться - мы не заблокируемся. В остальном - все работает так же, как и в небуфферизированном. Можно считать что небуфферизированный канал - это канал с буффером=0

Вообще лучше создавать буфферизированные каналы с примерно +- нужным буффером, так как сильно повышается пропускная способность - нам не надо ждать, пока обработается текущее значение в канале, чтобы начать обрабатывать следующее значение

Вот как читаем и пишем в каналы

```go
// создаем канал интов(не буфферизированный)
ch:=make (chan int)
// создаем буфферизированный канал с размером 1
chBuf:=make (chan int,1)
// Засунули в канал 4
ch<-4
// Вытащили 4 в переменную x
x:=<-ch
// Закрыли канал
close(ch)
```

Можно создать nil канал(`var nilChannel chan int`), но при обращении к нему(чтении, записи, попытке закрыть) будет deadlock, так как у него внутри полностью отсутствует структура

Также при создании канала мы можем указать направление канала и сделать канал только для записи или только для чтения. Выглядит следующим образом - `ch:=make(chan<- int)` - только запись или `ch:=make(<-chan int)` - только чтение

Также в аргументах функции мы можем указать, хотим ли мы только читать или писать в канале. Выглядит следующим образом `go func(chanForWriting chan<- int)` - для записи или `go func(chanForReading <-chan int)` - для чтения

Закрытие канала говорит о том, что больше данных в нем не появится. В закрытый канал писать нельзя, можно только читать. Закрытые каналы еще раз закрывать нельзя.

Если мы читаем данные из закрытого канала - нам будут приходить дефолтные значения

Проверить открыт или закрыт канал можно следуюшим образом

```go
// v - текущее значение в канале, ok - открыт или закрыт канал
v,ok := <-Channel
if !ok {
	// Канал закрыт
}

//Также можно реализовать чтение из канала с помощью цикла range
// Как только канал закрыт - цикл заканчивается
for v:=range Channel{
	// Что-то делаем
}
```

Пример реального использования каналов:

```go
func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	c <- sum // send sum to c
}

func main() {
	s := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
    // отдельно считаем левую часть слайса и передаем канал, в котором будет результат
	go sum(s[:len(s)/2], c)
    // отдельно считаем правую часть слайса и передаем канал, в котором будет результат
	go sum(s[len(s)/2:], c)
    // получаем данные из канала
	x, y := <-c, <-c // receive from c

	fmt.Println(x, y, x+y)
}
```

#### Select

По сути select - это switch case для каналов. Селект различает 3 типа операции - блокирующую, неблокирующую и дефолтную. С первым приоритетом он выполняет не блокирующие операции, со вторым приоритетом ждет возможности выполнения блокирующих операций(то есть блокирует дальнейшее выполнение кода и ждет). Ветка дефолта нужна для того, чтобы он выполнил если все операции заблокированы.

Среде нескольких неблокирующих операций селект выбирает рандомную

Пример

```go
bufferedChan := make(chan string,1)
bufferedChan <-"first"
select{
	// неблокирующая, так значение в канале есть
	case str := <-bufferedChan:
		//прочитали str
	// блокирующая, так как буффер заполнен
	case bufferedChan <- "second"
		// записали second в канал
}
```

Операция дефолта выполняется сразу если все операции заблокированы. Иногда необходимо подождать некоторый таймаут, после которого только мы будем считать что попытка чтения не удалась. Это можно сделать с помощью функции time.After следующим образом

```go
bufferedChan := make(chan string,1)
select{
	// Блокируется, так как ничего в канал не положено и никогда не будет, но вдруг таки случится чудо? Если чудо таки будем, то таймаут игнорируем и выполняем эту ветку
	case str := <-bufferedChan:
		//прочитали str
	// таймаут, после которого на чудо мы перестаем надеятся
	case <- time.After(time.Millisecond * 500)
		//чудо не случилось, больше ждать не будем
}
```

Также можно использовать код выше, чтобы поставить таймер на выполнение нескольких операций. Сколько выполнится - столько выполнится
Пример:

```go
unbufferedChan := make(chan string)
timer := time.After(time.Second)
go func() {
	defer close(unbufferedChan)
	// пытаемся за секунду выполнить максимальное колво операций
	for i:=0;i<1000;i++{
		select{
			//как только таймер вышел - мы перестаем выполнять операции
		case <-timer:
			return
			//полезная нагрузка
		default:
			time.Sleep(time.Nanosecond)
			unbufferedChan <-1
		}
	}
}()

```

#### Контекст

Контекст - это объект, который служит 2 целям:

1. Хранить значения(что то сродни $\_SESSION, в контексте передается общая информация о пользователе)
2. Сообщать о завершении(изнутри мы сможем узнать о состоянии - завершен контекст или не завершен)

2 основных контекста - это `context.Background` и `context.TODO`.

`context.Background` создает самый основной контекст, который потом используется в дальнейшем по программе

`context.TODO` служит как просто заглушка контекста, особенно полезен если разрабатывать приложение снизу вверх. По факту я его использовать скорее всего не стану

Контексты создаются цепочкой, от родителя. 2 Background контекста одновременно существовать не должны

При создании контекста можно указать, что контекст должен завершиться в определенное время или через некоторое время. Пример создания такого контекста:

```go
// Контекст завершиться в определенное время(3 секунды от текущего)
withDeadline,cancel:=context.WithDeadline(ctx,time.Now().add(time.Second*3))
// Контекст завершиться через 3 секунды
withDeadline,cancel:=context.WithTimeoout(ctx,time.Second*3)
```

В контекст можно положить данные по ключу. Однако это антипатерн, стараться избегать. Выглядит следующим образом:

```go
ctx:=context.Background()
withValue:=context.WithValue(ctx,"name","vasya")
withValue.Value("name") // выдаст vasya
```

Также контекст может сообщать о завершении. Контекст должен завершаться на том же уровне, где он был создан. Выглядит следующим образом:

```go
withCancel,cancel:=context.WithCancel(ctx)
witchCancel.Err() // Выведет nil, так как контекст не завершен
cancel()
witchCancel.Err() // Выведет ошибку context canceled

```

Также есть метод `Done()`. Он возвращает канал, из которого можно читать пустую структуру. При создании контекста через `WithDeadline` или `WithTimeout` в канал `Done` посылается значение. `Done` - блокирующая операция, если написать `<-withDeadline.Done()` то программа будет ждать дедлайна или истечения таймаута для продолжения

#### Worker pool - паттерн работы с контекстами

Этот паттерн показывает как можно работать с контекстами и корутинами для решения многопоточных проблем. В рамках паттерна мы создаем несколько воркеров - несколько инстансов функций с полезной нагрузкой, дожидаемся их завершения или вручную триггерим завершение при каком то условии, аккуратно завершаем их работу и выводим результат. Пример с комментариями:

```go
func workerPool() {


	// Мы создаем контекст, который будет жить 20 миллисекунд. За это время мы должны или завершить работу, или вылетим по таймауту
	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*20)
	// Ну или можно создать простой контекст без ограничения по времени
	//ctx, cancel := context.WithCancel(context.Background())
	// Сразу закрываем контекст по выходу из функции, чтобы не допустить утечек памяти
	defer cancel()

	// Wait группа, в которой будет счетчик корутин
	wg := &sync.WaitGroup{}
	// Создаем 2 канала - для входных данных и выходных. Вообще как будто лучше буфер сделать по количетству корутин, но это утверждение требует дополнительной проверки
	// По поводу размера буфера - определяется скорее имперически, чем некоторой формулой. На первое время при отсутствии других вводных - лучше делать по количетсву процессоров
	numbersToProcess, processedNumbers := make(chan int, 5), make(chan int, 5)
	// Мы создаем n корутин по количеству логических процессоров нашей системы. Ну или максимально доступному количеству
	for i := 0; i < runtime.NumCPU(); i++ {
		// Добавляем в wait группу новую корутину и запускаем полезную нагрузку
		wg.Add(1)
		go func() {
			defer wg.Done()
			worker(ctx, numbersToProcess, processedNumbers)
		}()
	}
	// По факту у нас сейчас есть runtime.NumCPU() количетсво корутин, которые готовы выполнять полезную нагрузку и сейчас ждут данные для обработки

	// В этой корутине мы заполняем полезную нагрузку
	go func() {
		for i := 0; i < 1000; i++ {
			// Если хотим, можем остановиться по какому то правилу, нормально завершить обработку и выйти из программы
			/*if i == 500 {
				cancel()
			}*/
			numbersToProcess <- i
		}
		// После окончания потока входных данных обязательно закрываем канал, чтобы показать, что больше данных не будет
		close(numbersToProcess)
	}()

	// Создаем корутину, которая будет дожидаться завершения работы всех воркеров, после чего она закроет канал выходных данных
	go func() {
		wg.Wait()
		close(processedNumbers)
	}()

	var counter int
	// Эта функция будет считать все данные в канале processedNubmers до тех пор, пока канал не закроется. Именно для этого мы закрываем его немного выше
	for resultValue := range processedNumbers {
		counter++
		fmt.Println(resultValue)
	}

	fmt.Println(counter)
}

// Сам воркер - полезная нагрузка наших корутин
// Заметь, что контекст передан первым аргументом - так должно быть всегда
// Также мы сразу показываем, что канал toProcess мы создаем исключительно для чтения данных, а канал processed - исключительно для записи. Типизация)
func worker(ctx context.Context, toProcess <-chan int, processed chan<- int) {
	// Каждый воркер будет бесконечно крутиться пока не получит завершение контекста(по сути досрочное завершение), либо пока канал не закроется
	for {
		select {
		// Пока контекст жив - этот выбор блокирующий и выбираться не будет
		// Когда контекст умрет - эта функция становится доступна к вызову и при очередном выполнении воркера функция завершит свою работу
		case <-ctx.Done():
			return
		// Тут функция блокируется пока в канале нет данных
		// Как только в канале появляются данные - функция разблокируется и выполняется пока канал не закроется
		// Именно поэтому очень важно закрывать канал после окончания работы с ним
		case value, ok := <-toProcess:
			if !ok {
				return
			}
			// имитация тяжелой работы
			time.Sleep(time.Millisecond)
			processed <- value * value
		}
	}
}
```

#### Каналы как промисы

Каналы можно использовать как промисы в их значении из js. То есть мы выполняем какой то код пока дожидаемся завершения грузной фукнции(допустим, запроса по http)
Пример:

```go
// Имитация бурной деятельности
func makeRequest(num int) <-chan string {
	responseChan := make(chan string)
	// Обрати внимание что бурная деятельность вынесена в отдельную корутину, чтобы не блокировать основной поток
	go func() {
		time.Sleep(time.Second)
		responseChan <- fmt.Sprintf("response number %d", num)
	}()
	return responseChan
}

func chanAsPromise() {
	// Отправляем 2 запроса
	firstResponseChan := makeRequest(1)
	secondResponseChan := makeRequest(2)
	// Пока эти запросы выполняются, мы делаем другую полезную работу
	fmt.Println("non blocking")
	//Здесь мы блокируем дальнейшую работу программы до тех пор пока не будут выполнены запросы
	fmt.Println(<-firstResponseChan, <-secondResponseChan)
}
```

#### Канал как mutex

Я так и не понял на кой ляд это надо. По факту мы как и в простом mutex блокируем выполнение блока кода, который имеет доступы до расшаренных переменных. С точки зрения читабельности это просто жопа, но может имеет лучший расход памяти при каких то условиях. Но для истории запишу

```go
func chanAsMutex() {
	var counter int
	// Создали канал структур, так как пустая структура ничего не весит
	mutexChan := make(chan struct{}, 1)
	wg := sync.WaitGroup{}

	for i := 0; i < 1000; i++ {
		wg.Add(1)

		go func() {
			defer wg.Done()
			// Как только одна из корутин дошла до этого участка кода, она положила значение и заблокировала остальные корутины, которые тоже хотят положить значение
			mutexChan <- struct{}{}

			counter++
			// После проведения необходимых работ корутина достала значение из канала и разблокировала остальные корутины. И цикл пошел заново
			<-mutexChan
		}()
	}

	wg.Wait()
	fmt.Println(counter)
}
```

#### ErrorGroup - пакет для работы с корутинами, которые могут выбрасывать ошибки

Иногда возникает такая проблема, что надо запустить несколько корутин и как только хотя бы одна из них выбросила ошибку - мы должны ее подхватить, запомнить и закончить выполнение остальных корутин. Для уменьшения количетства кода и гарантирования того, что запишется именно первая возникшая ошибка используется пакет `golang.org/x/sync/errgroup`.

Этот пакет во первых самостоятельно следит за waitGroup корутин, во вторых записывает только первую ошибку. Отличительная особенность - все корутины должны вернуть ошибку или nil. Вроде вполне стандартное требование.

Пример использования:

```go
// На основе контекста мы создаем error group
g, ctx := errgroup.WithContext(context.Background())

// В этом error group мы запускаем параллельно несколько корутин, каждая из которых может вывести ошибку (потенциально)
g.Go(func() error {
	time.Sleep(time.Second)
	select {
	case <-ctx.Done():
	default:
		fmt.Println("first started")
		time.Sleep(time.Second)
	}
	return nil
})

g.Go(func() error {
	fmt.Println("second started")
	return fmt.Errorf("unexpected error in request 2")
})

g.Go(func() error {
	select {
	case <-ctx.Done():
	default:
		fmt.Println("third started")
		time.Sleep(time.Second)
	}
	return nil
})

// Здесь мы дожидаемся выполнения всех корутин или до тех пор, пока хотя бы одна корутина не выкинет ошибку
if err := g.Wait(); err != nil {
	fmt.Println(err)
}
```

#### Пакет atomic

Пакет `sync\atomic` позволяет выполнять очень быстро некоторые атомарные функции над простыми числами int(int32, int64 ...). Список операций - `Add`, `Load`, `Store`, `Swap`, `CompareAndSwap`. Операции выполняются очень быстро, и при этом они безопасны по доступу данных, однако они все атомарные, то есть каждая операция выполняется отдельно.

Пакет применяется только в случае возможного data race

По сути этот пакет имеет смысл использовать тогда, когда есть простые вычисление. В остальных случаях лучше использовать mutex, который дает возможность блокировать кусок кода с несколькими операциями

Описание операций

1. `Add` - Изменить переменную на дельту
2. `Load` - Получить значение переменной
3. `Store` - Записать значение в переменную
4. `Swap` - Положить новое значение и достать предыдущее
5. `CompareAndSwap(variable *int, old int, new int ) swapped bool` - Если значение variable === old, то смени значение на new. И если это удалось - верни true, иначе - false

Если же мы хотим использовать пакет над другими типами и структурами, то можно определить переменную типа `atomic.Value`. У нее отсутствует функция Add, но она может работать с любыми типами данных

## Gracefull shutdown

Нормальное завершение работы программы, с очистками памяти и прочей ботвой. То есть закрытые соединений и прочее

Пример:

```go
sigChan := make(chan os.Signal,1)
signal.Notify(sigChan,syscall.SIGINT, syscall.SIGTERM)

select {
	case sig:=<-sigChan:
		// Выполняем операции по завершению
}
```

## Работа с проектом

Проекты обычно включают в себе работу с другими библиотеками и просто не только в одном файле

Для инициализации нового проекта необходимо в корне проекта использовать команду `go mod init НАЗВАНИЕ_ПРОЕКТА`. Таким образом мы определяем некоторый неймспейс, в котором и работаем

Для подтягивания зависимостей используется команда `go get "ПУТЬ ДО ПАКЕТА, ОБЫЧНО НА ГИТХАБЕ"`

После подтягивания всех зависимостей необходимо запустить команду `go mod tidy`. По сути это команда формирует собирает все сторонние зависимости в один файл на подобии package.json. Также она удаляет неиспользуемые зависимости

Команда `go mod vendor` позволяет установить зависимости локально в проект, то есть будет прямо в папке проекта созадана папка vendor со всеми зависимостями проекта. Это может быть удобно для прогонки тестов и деплое в CICD, чтобы не перекачивать каждый раз полностью зависимости

## Ссылки

Ссылка на тутор
https://www.youtube.com/@thisisit7267/videos
